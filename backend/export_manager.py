#!/usr/bin/env python3
"""Export Manager for AI-Driven Testing Project.

Handles exporting LLM output in different formats: JSON, HTTP, Markdown, etc.
"""

import json
import os
import datetime
from typing import Dict, Any


class ExportManager:
    """Manages export functionality for LLM outputs in various formats."""

    def __init__(self):
        """Initialize the ExportManager with supported formats."""
        self.supported_formats = ["json", "markdown", "http", "txt", "xml"]

    def get_supported_formats(self):
        """Return list of supported export formats."""
        return self.supported_formats.copy()

    def export_output(
        self,
        response_data: Dict[str, Any],
        prompt_data: Dict[str, Any],
        output_path: str,
        export_format: str = "markdown",
    ) -> str:
        """
        Export the LLM output in the specified format.

        Args:
            response_data: Dictionary containing response and metadata
            prompt_data: Dictionary containing prompt and model information
            output_path: Base path for output file
            export_format: Format to export (json, markdown, http, txt, xml)

        Returns:
            str: Path to the exported file
        """
        if export_format.lower() not in self.supported_formats:
            raise ValueError(
                f"Unsupported format: {export_format}. Supported: {self.supported_formats}"
            )

        # Create export data structure
        export_data = self._create_export_data(response_data, prompt_data)

        # Generate filename with format extension
        base_name = os.path.splitext(output_path)[0]
        output_file = f"{base_name}.{export_format.lower()}"

        # Export based on format
        if export_format.lower() == "json":
            return self._export_json(export_data, output_file)
        elif export_format.lower() == "markdown":
            return self._export_markdown(export_data, output_file)
        elif export_format.lower() == "http":
            return self._export_http(export_data, output_file)
        elif export_format.lower() == "txt":
            return self._export_txt(export_data, output_file)
        elif export_format.lower() == "xml":
            return self._export_xml(export_data, output_file)

    def _create_export_data(
        self, response_data: Dict[str, Any], prompt_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Create a standardized data structure for export."""
        return {
            "metadata": {
                "timestamp": datetime.datetime.now().isoformat(),
                "model": prompt_data.get("model", {}),
                "performance": {
                    "loading_time": response_data.get("loading_time", 0),
                    "response_time": response_data.get("final_time", 0),
                },
            },
            "prompt": {
                "text": prompt_data.get("prompt", ""),
                "length": len(prompt_data.get("prompt", "")),
            },
            "response": {
                "text": response_data.get("response", ""),
                "length": len(response_data.get("response", "")),
            },
        }

    def _export_json(
        self, export_data: Dict[str, Any], output_file: str
    ) -> str:
        """Export data as JSON format."""
        with open(output_file, "w", encoding="utf-8") as f:
            json.dump(export_data, f, indent=2, ensure_ascii=False)
        return output_file

    def _export_markdown(
        self, export_data: Dict[str, Any], output_file: str
    ) -> str:
        """Export data as Markdown format."""
        content = f"""# AI-Driven Testing Output

## Metadata
- **Timestamp**: {export_data['metadata']['timestamp']}
- **Model**: {export_data['metadata']['model'].get('name', 'Unknown')} ({export_data['metadata']['model'].get('id', 'Unknown')})
- **Loading Time**: {export_data['metadata']['performance']['loading_time']:.2f}s
- **Response Time**: {export_data['metadata']['performance']['response_time']:.2f}s

## Prompt
**Length**: {export_data['prompt']['length']} characters

```
{export_data['prompt']['text']}
```

## Response
**Length**: {export_data['response']['length']} characters

{export_data['response']['text']}

---
*Generated by AI-Driven Testing Project*
"""
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(content)
        return output_file

    def _export_http(
        self, export_data: Dict[str, Any], output_file: str
    ) -> str:
        """Export data as HTTP request/response format."""
        content = f"""HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: {len(json.dumps(export_data))}
X-Model: {export_data['metadata']['model'].get('id', 'unknown')}
X-Timestamp: {export_data['metadata']['timestamp']}
X-Loading-Time: {export_data['metadata']['performance']['loading_time']}
X-Response-Time: {export_data['metadata']['performance']['response_time']}

{json.dumps(export_data, indent=2)}
"""
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(content)
        return output_file

    def _export_txt(
        self, export_data: Dict[str, Any], output_file: str
    ) -> str:
        """Export data as plain text format."""
        content = f"""AI-Driven Testing Output
========================

Timestamp: {export_data['metadata']['timestamp']}
Model: {export_data['metadata']['model'].get('name', 'Unknown')} ({export_data['metadata']['model'].get('id', 'Unknown')})
Loading Time: {export_data['metadata']['performance']['loading_time']:.2f}s
Response Time: {export_data['metadata']['performance']['response_time']:.2f}s

PROMPT ({export_data['prompt']['length']} characters):
{'-' * 50}
{export_data['prompt']['text']}

RESPONSE ({export_data['response']['length']} characters):
{'-' * 50}
{export_data['response']['text']}

Generated by AI-Driven Testing Project
"""
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(content)
        return output_file

    def _export_xml(
        self, export_data: Dict[str, Any], output_file: str
    ) -> str:
        """Export data as XML format."""

        def escape_xml(text: str) -> str:
            """Escape XML special characters."""
            return (
                text.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace('"', "&quot;")
                .replace("'", "&#39;")
            )

        content = f"""<?xml version="1.0" encoding="UTF-8"?>
<ai_testing_output>
    <metadata>
        <timestamp>{export_data['metadata']['timestamp']}</timestamp>
        <model>
            <name>{escape_xml(export_data['metadata']['model'].get('name', 'Unknown'))}</name>
            <id>{escape_xml(export_data['metadata']['model'].get('id', 'Unknown'))}</id>
        </model>
        <performance>
            <loading_time>{export_data['metadata']['performance']['loading_time']}</loading_time>
            <response_time>{export_data['metadata']['performance']['response_time']}</response_time>
        </performance>
    </metadata>
    <prompt length="{export_data['prompt']['length']}">
        <![CDATA[{export_data['prompt']['text']}]]>
    </prompt>
    <response length="{export_data['response']['length']}">
        <![CDATA[{export_data['response']['text']}]]>
    </response>
</ai_testing_output>
"""
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(content)
        return output_file

    def export_multiple_formats(
        self,
        response_data: Dict[str, Any],
        prompt_data: Dict[str, Any],
        output_path: str,
        formats: list = None,
    ) -> Dict[str, str]:
        """
        Export the output in multiple formats.

        Args:
            response_data: Dictionary containing response and metadata
            prompt_data: Dictionary containing prompt and model information
            output_path: Base path for output files
            formats: List of formats to export (defaults to all supported formats)

        Returns:
            Dict[str, str]: Mapping of format to exported file path
        """
        if formats is None:
            formats = self.supported_formats

        exported_files = {}
        for fmt in formats:
            try:
                file_path = self.export_output(
                    response_data, prompt_data, output_path, fmt
                )
                exported_files[fmt] = file_path
                print(f"✅ Exported {fmt.upper()}: {file_path}")
            except Exception as e:
                print(f"❌ Failed to export {fmt.upper()}: {e}")
                exported_files[fmt] = None

        return exported_files

    def export_content(
        self, content: str, format_type: str, filename: str
    ) -> str:
        """
        Export content in specified format.

        Args:
            content: Content to export
            format_type: Format type (json, markdown, http, txt, xml)
            filename: Output filename

        Returns:
            str: Path to exported file
        """
        if format_type.lower() not in self.supported_formats:
            raise ValueError(f"Unsupported format: {format_type}")

        # Create fake response/prompt data for existing export method
        response_data = {"output": {"markdown": content}}
        prompt_data = {
            "model": {"name": "unknown"},
            "input": {"user_message": ""},
        }

        return self.export_output(
            response_data, prompt_data, filename, format_type
        )

    def export_all_formats(
        self, content: str, base_filename: str
    ) -> Dict[str, str]:
        """
        Export content in all supported formats.

        Args:
            content: Content to export
            base_filename: Base filename (without extension)

        Returns:
            Dict[str, str]: Dictionary mapping format names to file paths
        """
        exported_files = {}

        for fmt in self.supported_formats:
            try:
                filename = f"{base_filename}.{fmt}"
                if fmt == "json":
                    filename = f"{base_filename}_formatted.json"

                file_path = self.export_content(content, fmt, filename)
                exported_files[fmt] = file_path
            except Exception as e:
                print(f"❌ Failed to export {fmt.upper()}: {e}")
                exported_files[fmt] = None

        return exported_files
